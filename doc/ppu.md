# Tile

PPUのアドレス空間 0x0000 ~ 0x1fff は CHR ROM用に予約されており、視覚的データが格納されている

データはタイルと呼ばれる 8x8 のピクセルに分割されており、各ピクセル2bitの値を持ち、4つの色を選べる(00, 01, 10, 11)

4つの色が何になるかは、そのタイルに対応する属性で指定されたパレットによって決まる

タイルのサイズは 8 * 8 * 2 = 128 bits であり、CHR ROM のスペースが 8KiB なので 8KiB / 128bits = 512tiles 格納出来る

CHR ROM は 0x0000 ~ 0x0fff, 0x1000 ~ 0x1fff の大きく2つに分けて扱われ、それらタイルの集合をバンクと呼ぶ

# Pattern table

2つのバンクのうち、現在レンダリングに使われているどちらか

インデックスにより、各タイルを参照できるようにしたもの

# Name table

画面の状態を表すテーブル

VRAM上でアドレス範囲 0x2000 ~ 0x23BF に格納されており、32 tiles(256 pixels) x 30 tiles (240 pixels) 分の情報を、各バイトが1タイルに対応する形で構成されている

その値は、使用するタイルをパターンテーブルのインデックスで表したものである

# Palette table

現在使用しているパレット

レンダリングする際に、タイルの値で参照し、そのピクセルの実際の色を決める


# レンダリングの順序

scanlines 0~239, cycles 1~256 間で、1サイクルに1ピクセルごと、全体で 256x240 ピクセルがレンダリングされる 

レンダリングに使用する最初の2つタイルは、前のスキャンラインの 321~336 サイクル間で事前にフェッチされ用意されている

それ以降のタイルは、1~256 サイクル間で、8サイクルごとに1つのタイルがフェッチされ、常にピクセルがレンダリングされる前に2つのタイルが用意される形になる

タイルは8ピクセルの高さを持つが、レンダリングは1ピクセル行ごとに行われるので

AAABBB
AAABBB
AAABBB

このような2つのタイルA,Bがあったとすると(簡略化のため3x3とする)

AAABBB,AAABBB,AAABBB とレンダリングされるので、同じタイルがそれぞれ3回フェッチされることになる(つまり実際のタイルでは8回) 

# スクロール

なぜ、事前に1つではなく2つタイルが用意されるのかというと、スクロールで2つのタイルが必要になる場合があるからである

例えば、以下のタイルがあり、3サイクルごとに1つのタイルがフェッチされるとする

AAABBB
AAABBB
AAABBB

事前にAのタイルをフェッチしてると、Aのレンダリング中の3サイクルで、Bのタイルが用意できるので、Bのレンダリングに間に合うのだが

1つ横にスクロールされていると

 X
AAABBB
AAABBB
AAABBB

Aのレンダリングは2サイクルで終わり、Bのタイルがフェッチされる前に、Bのレンダリングに移ってしまう

なので事前に2つのタイルを用意しておく必要がある

Y方向へのスクロールでは同様のことは考慮しなくてよい、なぜなら1ピクセル行ずつレンダリングされるからである


# スプライト

前のスキャンラインで、OAMを走査して次のスキャンラインにかかるスプライトを見つけ、セカンダリOAMにコピーする

- この時、y = 今のスキャンライン+1 とすべきなのか y = 今のスキャンライン とすべきなのか？後者ならスプライトのy座標は+1ずれることになる

セカンダリOAMを走査し、タイルがxに重なっているか調べる。複数ある場合は、インデックスが若い順にレンダリングされる。

ただし、透明スプライトの場合は、その次の非透明のスプライトがレンダリングされる

(x: 0, y: 0) のスプライトがあった場合

1. scanline: 0 で次のスキャンラインで表示するスプライトとして secandary OAM に確保する
2. scanline: 1 で確保したタイルを表示する。この時、スプライトデータとしては y = 0 だが、実際は y = 1 の位置に表示されることになる

0行目にスプライトを表示することは出来ない
y = 239 以上のスプライトは表示されない


# スクロールとレンダリング

## ざっくりとした流れ

1. 可視エリア(カメラと考えても良い)の左上の座標を9ビットのX,Y座標で割り出す 
2. X座標の下位8ビットを PPUSCROLL($2005) に書き込む
3. Y座標の下位8ビットを PPUSCROLL に書き込む
4. X, Yの最上位の9位ビットを PPUCTRL($2000) にそれぞれ書き込む(これが左上で見える名前テーブルである)

PPUSCROLLへの書き込みは、VBLANKの終わり、レンダリングが始まる直前で反映される

従って、VBLANKが終わる前に書き込まなければならない

また、PPUADDR($2006) は内部的に PPUSCROLL, PPUCTRL と状態を共有しているため、PPUADDR への書き込みはスクロール位置を上書きする

よって、PPUSCROLL と PPUCTRL への書き込みは PPUADDR を使用している VRAM の更新より後に行われなければならない


## PPU 内部レジスタ

v: 現在の VRAM アドレス(スクロール、名前テーブルなどから構成される。15bit)

t: 一時 VRAM アドレス(スクロールなど変更された値は一時的にこちらに保存され、適切なタイミングでvに反映することで現在のレンダリングには影響がないようにする。15bit)

x: タイル内のピクセル単位のXスクロール (3bit)

w: PPUSCROLL、PPUADDR の X/Y、上位/下位 を切り替えるラッチ

現在のVRAMアドレスは $2007 を通してPPUメモリを読み書きするのと、名前テーブルをフェッチするのに使う

背景をレンダリングしている時、現在描かれているタイルを指すように更新される

15bit レジスタは以下のように構成されている

```text
yyy NN YYYYY XXXXX
||| || ||||| +++++-- coarse X scroll
||| || +++++-------- coarse Y scroll
||| ++-------------- nametable select
+++----------------- fine Y scroll
```

v レジスタは15bit幅だが、PPUのメモリ空間は14bit幅である。最上位ビットは $2007 を通してメモリをアクセスする際には使われない

加えて fine Y はミラーダウンされて無視されるので、実質メモリにアクセスする際に使われるのは nametable とタイル単位のX,Yスクロールだけである

例えば、nametable(01)、X,Y(0) だとすると

`0b01_00000_00000` となり、16進数では `0x400` になり、2番目のテーブルを正しく指していることが分かる

さらに、(Y=1) とすると

`0b01_00001_00000` となり、16進数では `0x420`, `0x20=32` なので、正しく1行タイル分スクロール出来ていることも分かる


## レジスタ制御

d: data
A~H: each bit of the data

### $2000(PPUCTRL) write

```text
t: ...GH.. ........ <- d: ......GH
   <used elsewhere> <- d: ABCDEF..
```

### $2002(PPUSTATUS) read

```text
w:                  <- 0
```

### $2005(PPUSCROLL) write (w = 0)

```text
t: ....... ...ABCDE <- d: ABCDE...
x:              FGH <- d: .....FGH
w:                  <- 1
```

### $2005(PPUSCROLL) write (w=1)

```text
t: FGH..AB CDE..... <- d: ABCDEFGH
w:                  <- 0
```

### $2006(PPUADDR) write (w=0)

```text
t: .CDEFGH ........ <- d: ..CDEFGH
       <unused>     <- d: AB......
t: Z...... ........ <- 0 (bit Z is cleared)
w:                  <- 1
```

### $2006(PPUADDR) write (w=1)

```text
t: ....... ABCDEFGH <- d: ABCDEFGH
v: <...all bits...> <- t: <...all bits...>
w:                  <- 0
```

### $2007(PPUDATA) read

データバッファに入っているデータを取り出す

VRAMからvが指すデータを読み取り、データバッファに移す

v に PPUCTRL の VRAM increment ビットに応じて、1か32を足す

取り出したデータを返す。つまりデータは読み取りから 1 read 分遅延して返される

### $2007(PPUDATA) write

v が指すVRAM領域に書き込み、PPUCTRL の VRAM increment ビットに応じて、1か32を足す



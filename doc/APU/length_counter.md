長さカウンターは音が鳴る時間を設定するためのユニットであり、カウンタと停止フラグを含む

一度値を読み込んだら、適切にカウントダウンすることができる(length counter halt フラグがクリアであれば)

0に到達すると対応するチャンネルがミュートされる

# 値の読み込み

enable フラグがセットされると対応するレジスタのLフラグの値を元に、テーブルを参照し長さを得る

# クロック

$4015の enable フラグがクリアされたとき、長さカウンターは0になり、再度 enable フラグがセットされるまで変更することが出来ない(長さカウンタの元の値は破棄される)

enable フラグがセットされた時の即時の作用はない(例えばどのような効果が？)

フレームカウンターによってクロックされた時、長さカウンターは以下の状況を除き、デクリメントされる

1. 長さカウンターが0
2. halt flag がセットされている

# 内部的な話

実際のAPUでは長さカウンターはすでに長さが0の時にクロックされるとチャンネルをミュートする

# 不明な点

- レジスターに書き込んだデータはどのタイミングでロードされるのか？
- haltフラグなどを設定した時に遅延や副作用はあるのか？
    - $4003/$4007 への書き込みが、長さカウンターをリロードさせる模様

# halt フラグと長さの更新のタイミング

他のエミュレーターの実装を見てみると、$4015への書き込みで即座に長さとhaltの状態の更新をしておらず、保留している
次の cpu tick でフレームカウンターによるクロックの後に更新しているようだ

時系列としては
1. $4015への書き込み(保留)
2. cpu tick (-> 各チャンネルのタイマー, フレームカウンター)
3. フレームカウンターによる長さカウンターのクロック
4. 保留していた各チャンネルの長さカウンターの状態の更新
5. サンプルしてバッファを更新

長さカウンターは直接他のユニットに影響を与えない(サンプル時に最終的なゲートで値を参照される)ので、長さカウンターのみを考える

要は、halt/値を書き込んでも次のtickでのフレームカウンターのクロックが(あれば)先ということらしい

1. レジスターへ新しい値を書き込む(長さカウンターの状態の更新は保留)
2. 長さカウンターのクロック
3. 長さカウンターの状態を更新
4. サンプル

しかし少しおかしいことに気づいた
2は意味があるのか？2の結果は、3で消されてしまうのに？実質レジスターへの書き込み直後の1cpu cycleでの長さカウンタのクロックを無効にしているだけではないか？

正直よく分からん、そもそもレジスタに書き込んだ直後のtickであるフレームに到達するのがレアケースに見えるし、wikiのどこにもそんな仕様書いてないし、まあとりあえず即座に更新する方法で実装してみる
